import type { ComputedRef, Ref, ShallowRef } from 'vue';
import type { DefaultRecordType, FinallyColumnType, Key, Position, RenderedCell } from '../components/interface';
import type { AppendCellRange, CellRangesItem, FormatRangeCellTextParams, RangeCell, RowPinned, SelectedRangeItem } from './RangeInterface';
import { useCellNavigation } from './useCellNavigation';
export declare const useProvideRangeStore: (parmas: {
    allColumns: ShallowRef<FinallyColumnType<DefaultRecordType>[]>;
    flattenData: ShallowRef<DefaultRecordType[]>;
    prefixCls: ComputedRef<string>;
    rangeSelection: ComputedRef<boolean | 'single'>;
    getRowByFlattenIndex: (index: number) => DefaultRecordType;
    rootRef: Ref<HTMLDivElement>;
    bodyRef: Ref<HTMLDivElement>;
    allCellProps: Ref<Record<string, Record<string, RenderedCell>>>;
    tabGuardTopRef: Ref<HTMLDivElement>;
    tabGuardBottomRef: Ref<HTMLDivElement>;
    ensureCellRowVisible: (cell: RangeCell) => void;
    ensureCellColumnVisible: (cell: RangeCell) => void;
    latestRangeStartCell: ShallowRef<RangeCell>;
    scrollTo: (pos?: number | Position, behavior?: 'auto' | 'smooth', skipAnimate?: boolean) => void;
    scrollLeft: Ref<number>;
    scrollTop: Ref<number>;
    showVerticalScrollbar: Ref<boolean>;
    showHorizontalScrollbar: Ref<boolean>;
    getIndexsByKey: (key: Key) => number[];
    formatRangeCellText: (parmas: FormatRangeCellTextParams) => string;
    editCellKeys: Ref<string[]>;
    copyDelimiter: Ref<string>;
}) => {
    getSelectedRange: () => SelectedRangeItem[];
    appendCellToSelectedRange: (params: AppendCellRange) => void;
    clearAllSelectedRange: () => void;
    setCellRanges: (val: CellRangesItem[]) => void;
    getCellRangeCount: (cell: RangeCell) => number;
    navigationService: {
        getNextCellToFocus: (keyCode: number, focusedCell: RangeCell, ctrlPressed?: boolean) => RangeCell | {
            rowIndex: any;
            rowPinned: any;
            column: any;
        };
        getNextTabbedCell: (gridCell: RangeCell, backwards: boolean) => {
            rowIndex: number;
            column: FinallyColumnType<DefaultRecordType>;
            rowPinned: RowPinned;
        };
        getLastBodyCell: () => {
            rowIndex: any;
            rowPinned: any;
        };
        navigateToNextCell: (event: KeyboardEvent, currentCell: RangeCell) => void;
        onTabKeyDown: (previous: RangeCell, keyboardEvent: KeyboardEvent) => void;
        tabToNextCellCommon: (previous: RangeCell, backwards: boolean) => boolean;
        getFirstCellToFocus: (backwards: boolean) => void;
        getLastCellToFocus: (backwards: boolean) => void;
        getRowAbove: (rowPosition: RangeCell) => {
            rowIndex: number;
            rowPinned: RowPinned;
        };
        getCellAbove: (lastCell: RangeCell) => {
            rowIndex: number;
            column: FinallyColumnType<DefaultRecordType>;
            rowPinned: RowPinned;
        };
        getRowBelow: (rowPosition: RangeCell) => {
            rowIndex: number;
            rowPinned: RowPinned;
        };
    };
    copySelectedRange: () => void;
    onBodyKeydown: (keyboardEvent: KeyboardEvent) => void;
};
export declare const useInjectRangeStore: () => {
    cellRanges: ShallowRef<CellRangesItem[]>;
    onDragStart: (mouseEvent: MouseEvent) => void;
    onDragging: (mouseEvent: MouseEvent) => void;
    setRangeToCell: (cell: RangeCell, appendRange?: boolean) => void;
    extendLatestRangeToCell: (cellPosition: RangeCell) => void;
    isCellInAnyRange: (cell: RangeCell) => boolean;
    getRangeCellClass: (cell: RangeCell) => string;
    enableRangeSelection: ComputedRef<boolean>;
    singleRangeSelection: ComputedRef<boolean>;
    getDisplayedColBefore: (col: FinallyColumnType) => FinallyColumnType<DefaultRecordType>;
    getDisplayedColAfter: (col: FinallyColumnType) => FinallyColumnType<DefaultRecordType>;
    navigationService: ReturnType<typeof useCellNavigation>;
    extendLatestRangeInDirection: (event: KeyboardEvent) => RangeCell;
    allDisplayedColumns: ComputedRef<FinallyColumnType<DefaultRecordType>[]>;
    focusCell: (cell: RangeCell) => void;
    ensureCellVisible: (cell: RangeCell) => void;
    getCellRangeCount: (cell: RangeCell) => number;
    intersectLastRange: (fromMouseClick: boolean) => void;
    level: number;
};
